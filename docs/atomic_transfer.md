# Atomic coin transfer

API and protocol for atomic transfer of two statecoins. 

The purpose of the atomic transfer protocol is to enable two transfers to be completed in a way that they both complete or neither of them do. This effectively means that the transfer-receiver and key update is only performed if both receivers have the correct information to proceed. Once each receiver has verified that the transfer message they have received is valid, then the other party can be allowed to complete transfer-receiver. 

To enable this there needs to be a mechanism to prevent the transfer-receiver being completed before the other party has verified the transfer message. If both parties verify, then transfer-receiver can proceed, otherwise the key shares are not updated and ownership of the coins remains as it was. 

The process is performed by each party in the atomic transfer supplying a `batch_id` in the transfer-sender message. The use of this (as opposed to leaving this null) is that the statecoin is in a special *locked* state for a timeout period after the first `batch_id` is submitted. During this locked status two things are prevented 1) The sender cannot perform another `/transfer/sender` operation on the same coin and 2) `/transfer/receiver` cannot be performed until all coins with the same `batch_id` are *unlocked* by the owners unlocking the coins with a new `/transfer/unlock` function. At the end of the timeout (if all coins have not been unlocked), the `/transfer/receiver` function will still be blocked (i.e. return error) but the original owner can repeat `/transfer/sender` again with a null `batch_id` to regain control of the coin. 

## Protocol

The statecoin DB table will have 3 additional columns: `batch_id` (string), `batch-time` (integer) and `locked` (boolen). By default `batch_id`, `batch-time` are null and `locked` is `false`. The server is configured with `batch-timeout` parameter in seconds. 

This will then proceed as follows:

1. The two parties that want to engage in an atomic transfer cooperate and share a `batch_id` (this is just a random UUID generated by one of the participants and shared). 
2. The two parties swap `sc` addresses that they want the other coin paid to. 
3. They each perform `/transfer/sender {statechain_id, batch_id, auth_sig, new_user_auth_key}` with the `batch_id`. 
4. If the `batch_id` is provided (and not null) the server adds this to the `batch_id` DB column for the `statechain_id` and updates the `locked` status to `true`. 
The server then checks all other statecoins to see if the same `batch_id` is used for any other coin (DB query). 
If there are no other coins with this `batch_id`, then it adds the current time (unix epoch time in seconds) to the `batch-time` column. 
If there are any other coin(s) with this `batch_id` then the same `batch-time` of that coin(s) is copied to the coin `batch-time` column. 

With this logic, it does not mater which order the coins call `/transfer/sender`, the first call with a specific `batch_id` will set the initial `batch-time` for the transfer. 

5. When `/transfer/sender` is called for any coin, if the `batch_id` is not null and `batch-time` + `batch-timeout` is less than the current time, then this call will return with an error.
If `batch-time` + `batch-timeout` is greater than the current time, the server checks if any other coins have the same `batch_id`. For each coin that shares the same`batch_id`, if all `locked` are false, then the transfer-sender returns with an error. 
Otherwise `/transfer/sender` can be called again with a null or different `batch_id`. If called with null `batch_id` then `batch-time` is set to null and `locked` to false. 
6. If `/transfer/receiver` is called on any coin and `batch_id` and `batch-time` are set (not null) and `locked` is true, then this function should return an error. 
8. If `/transfer/receiver` is called on any coin and `batch_id` and `batch-time` are set (not null) and `batch-time` + `batch-timeout` is less than the current time, and `locked` is false, then the server checks if any other coins have the same `batch_id`. For each coin that shares the same`batch_id`, if all `locked` are false, then the function proceeds with the key update, otherwise it returns with an error. 
9. Each participant in an atomic transfer verfies that they receive a transfer message for their address (with `/transfer/get_msg_addr`) and verifies the message. If all OK, then the participant calls a function `/transfer/unlock {statechain_id, auth_sig}` which changes the `locked` status of the coin (`statechain_id`) to `false`. 
If the `batch-time` + `batch-timeout` is greater than the current time, then the `/transfer/unlock` function should not unlock and instead return an error. 

The outcomes of this protocol:

All participants call `/transfer/unlock` within the `batch-time` then `/transfer/receiver` can be performed for all coins. 

Any participant doesn't call `/transfer/unlock` within the `batch-time` then no-one can call  `/transfer/receiver` and each owner can call `/transfer/sender` again to recover the coin. 