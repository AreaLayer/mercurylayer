# Atomic transfer protocols

## Multiple statecoins

The purpose of the atomic transfer protocol is to enable two (or more) transfers to be completed in a way that they all complete or none of them do. This effectively means that the transfer-receiver function and key update is only completed if both receivers have the correct information to proceed. Once each receiver has verified that the transfer message they have received is valid, then the other parties can be allowed to complete transfer-receiver. 

To enable this there needs to be a mechanism to prevent the transfer-receiver being completed before the other parties have verified their transfer messages. If all parties verify, then transfer-receiver can proceed, otherwise the key shares are not updated and ownership of the coins remains with the inital owner. 

The process is performed by each party in the atomic transfer supplying a `batch_id` in the transfer-sender message. The use of this (as opposed to leaving this null) is that the statecoin is put into a special *locked* state for a configured timeout period after the first `batch_id` is submitted. During this locked status two things are prevented 1) The sender cannot perform another `/transfer/sender` operation on the same coin (i.e. to send to a different address) and 2) `/transfer/receiver` cannot be performed until all coins with the same `batch_id` are *unlocked* by all the owners unlocking the coins with a new `/transfer/unlock` function. At the end of the timeout (if all coins with a specified `batch_id` have not been unlocked), the `/transfer/receiver` function will still be blocked (i.e. return error) but the original owner can repeat `/transfer/sender` again with a null `batch_id` to regain control of the coin. 

### Protocol

The statecoin DB table will have 3 additional columns: `batch_id` (string), `batch-time` (integer) and `locked` (boolen). By default `batch_id`, `batch-time` are null and `locked` is `false`. The server is configured with `batch-timeout` parameter in seconds (in practice this will be some number of minutes). 

The atomic transfer will then proceed as follows:

1. The two parties that want to engage in an atomic transfer cooperate and share a `batch_id` (this is just a random UUID generated by one of the participants and shared with the other). 
2. The two parties swap `sc` addresses that they want the other coin paid to. 
3. They each perform `/transfer/sender {statechain_id, batch_id, auth_sig, new_user_auth_key}` with the `batch_id` paying to the other party `new_user_auth_key` and then create and upload the transfer message. 
4. If the `batch_id` is set in `/transfer/sender` (and not null) the server adds this to the `batch_id` DB column for the `statechain_id` and updates the `locked` status to `true`. 
5. The server then checks all other statecoins to see if the same `batch_id` is used for any other coin (DB query). 
If there are no other coins with this `batch_id`, then it adds the current time (unix epoch time in seconds) to the `batch-time` column. 
If there are any other coin(s) with this `batch_id` then the same `batch-time` of those coin(s) is copied to the coin `batch-time` column. 

> With this logic, it does not mater which order the coins call `/transfer/sender`, the first call with a specific `batch_id` will set the initial `batch-time` for the atomic transfer. 

When `/transfer/sender` is called for any coin, if the `batch_id` is not null and `batch-time` + `batch-timeout` is *less* than the current time, then this call will return with an error.
If `batch-time` + `batch-timeout` is *greater* than the current time, the server checks if any other coins have the same `batch_id`. For each coin that shares the same`batch_id`, if all `locked` are false, then the transfer-sender returns with an error (in this case all participants have verified the transfer message and the atomic transfer must complete). 
Otherwise `/transfer/sender` can be called again with a null or different `batch_id`. If called with null `batch_id` then `batch-time` is set to null and `locked` to false. 

6. Each participant in an atomic transfer polls `/transfer/get_msg_addr` with their receive address within the timeout period. If they receive a transfer message, they fully verify as usual. If all OK, then the participant calls a function `/transfer/unlock {statechain_id, auth_sig}` (where the auth sig is over `statechain_id`) which changes the `locked` status of the coin (`statechain_id`) to `false`.
If the `batch-time` + `batch-timeout` is greater than the current time, then the `/transfer/unlock` function should not unlock and instead return an error. 

7. If `/transfer/receiver` is called on any coin and `batch_id` and `batch-time` are set (not null) and `batch-time` + `batch-timeout` is less than the current time, and `locked` is false, then the server checks if any other coins have the same `batch_id`. For each coin that shares the same`batch_id`, if all `locked` are false, then the function proceeds with the key update, otherwise it returns with an error. 
If `/transfer/receiver` is called on any coin and `batch_id` and `batch-time` are set (not null) and `locked` is true, then this function should return an error. 

The outcomes of this protocol:

All participants call `/transfer/unlock` within the `batch-time` then `/transfer/receiver` can be performed for all coins. 

Any participant doesn't call `/transfer/unlock` within the `batch-time` then no-one can call `/transfer/receiver` but each owner can call `/transfer/sender` again to recover the coin. 

## Lightning Latch transfer

A latch transfer enables a statecoin to be transferred on condition of the sucessful payment of a Lightning network invoice. This is a protocol that enforces atomicity of the statecoin transfer and lightning payment - it can be used for the sale of a statecoin UTXO for an arbtrary amount of bitcoin in a private and non-custodial way without counterparty risk. 

The latch transfer protocol uses the method of *Hodl invoices* where funds are locked until the payment hash pre-image is revealed. A hodl ivoice can be resolved in one of two ways: 

1. The payment is completes when the recipient releases the preimage (to the payment route). 
2. The payment is canceled if the recipient does not release the preimage and the invoice expires.

Using this mechanism, a lightning network payment can be made but only completed if some condition is met - specifically if a specified statecoin transfer is made and verified. In this case the statechain entity (i.e. the mercury server) can both generate and release the payment hash pre-image on successful completion of the statecoin transfer. 

### Protocol

The statecoin DB table will have 4 additional columns: `batch_id` (string), `batch-time` (integer), `pre-image` (string), `locked_1` (boolen) and `locked_2` (boolen). By default `batch_id`, `batch-time` are null and `locked` is `false`. The server is configured with `batch-timeout` parameter in seconds (in practice this will be some number of minutes). 

The transfer will then proceed as follows:

1. There are two parties: party 1 has a statecoin they want to sell and party 2 wants to receivie it and pay an agreed price via LN.
2. Party 1 generates a `batch_id` (this is just a random UUID) and shares with party 2.
3. Party 1 calls `/transfer/paymenthash` with the `batch_id` and authenticated `statechain_id` for the coin. The server generates a secret `preimage` and stores it in the statecoin table with a new row and `batch-time` set as current time and `locked_1` to `true` and `locked_2` to `true`, and returns the `paymenthash` to Party 1. 
4. Party 2 generates a `sc` addresses that they want the UTXO sent to. This is sent to Party 1. 
5. Party 1 generates an invoice with the `paymenthash` and sends to Party 2. 
6. Party 1 performs `/transfer/sender {statechain_id, batch_id, auth_sig, new_user_auth_key}` with the `batch_id` paying to the other party `new_user_auth_key` and then create and upload the transfer message.
7. Party 2 makes the LN payment for the invoice, but cannot complete as they don't know the pre-image.
8. Party 1 verifies the payment and calls `/transfer/unlock` with `statechain_id` and signed with their `auth_key`. If time is within `batch-time` + `batch-timeout` this sets the `locked_1` value to `false`.
9. Party 2 verifies the transfer message and calls `/transfer/unlock` with `statechain_id` and signed with their `new_user_auth_key`. If time is within `batch-time` + `batch-timeout` this sets the `locked_2` value to `false`.
10. Party 1 then calls `/transfer/preimage` with `statechain_id` and signed with their `new_user_auth_key`. If `locked_1` and `locked_2` and both false, then the `preimage` is returned and the LN payment can be completed.
11. Party 2 completes `/transfer/receiver`. If `locked_1` and `locked_2` and both false then the keyupdate is completed.

If both of the `/transfer/unlock` operations are not completed within the `batch-timeout` then both: 1. the LN invoice will timeout and cancel and 2. Party 1 performs another `/transfer/sender` and `/transfer/receiver` operation returning control of the coin. 

The outcomes of this protocol:

All participants call `/transfer/unlock` within the `batch-time` then `/transfer/receiver` can be performed and the pre-image revealed. 

Any participant doesn't call `/transfer/unlock` within the `batch-time` then no-one can call `/transfer/receiver` but party 1 can call `/transfer/sender` again to recover the coin, and the LN payment will fail. 


